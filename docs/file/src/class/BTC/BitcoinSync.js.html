<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/class/BTC/BitcoinSync.js | lumi-web-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Lumi Wallet Core - Web Version"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="lumi-web-core"><meta property="twitter:description" content="Lumi Wallet Core - Web Version"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/lumiwallet/lumi-web-core"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Wrapper.js~Wrapper.html">Wrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~Wallet.html">Wallet</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#class">class</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/class/Core.js~Core.html">Core</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/class/WalletWrapper.js~WalletWrapper.html">WalletWrapper</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#class-btc">class/BTC</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/class/BTC/BitcoinSync.js~BitcoinSync.html">BitcoinSync</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/class/BTC/BitcoinTx.js~BitcoinTx.html">BitcoinTx</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#class-eth">class/ETH</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/class/ETH/EthereumSync.js~EthereumSync.html">EthereumSync</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/class/ETH/EthereumTx.js~EthereumTx.html">EthereumTx</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#helpers">helpers</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/handleErrors.js~CustomError.html">CustomError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-calcBtcTxSize">calcBtcTxSize</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-derive">derive</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateMnemonic">generateMnemonic</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getBtcAddress">getBtcAddress</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEthAddress">getEthAddress</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEthAddressByNode">getEthAddressByNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEthPrivateKey">getEthPrivateKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEthPublicKey">getEthPublicKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getXprv">getXprv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hdFromSeed">hdFromSeed</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hdFromXprv">hdFromXprv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeRawBtcTx">makeRawBtcTx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeRawEthTx">makeRawEthTx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mnemonicToEntropy">mnemonicToEntropy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mnemonicToSeed">mnemonicToSeed</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-privateKeyToWIF">privateKeyToWIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-requestHandleErrors">requestHandleErrors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toFormatDecimal">toFormatDecimal</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/class/BTC/BitcoinSync.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import Request from &apos;@/helpers/Request&apos;
import {getBtcAddress, privateKeyToWIF} from &apos;@/helpers/coreHelper&apos;

/**
 * Class BitcoinSync.
 * This class allows you to get information about the balance on a bitcoin wallet,
 * the list of unspent, a set of addresses that participated in transactions, and a list of transactions
 * @class
 */

export default class BitcoinSync {
  /**
   * Create a BitcoinSync
   * @param {Object} node - External Bitcoin node
   * @param {Object} internalNode - Internal Bitcoin node
   * @param {Object} api - A set of URLs for getting information about bitcoin addresses
   */
  constructor (node, internalNode, api) {
    this.node = node
    this.internalNode = internalNode
    this.api = api
    this.balance = 0
    this.latestBlock = 0
    this.unspent = []
    this.addresses = {
      external: [],
      internal: [],
      empty: {},
      fullList: [],
      all: []
    }
    this.deriveAddress = {
      internal: {},
      external: {}
    }
    this.transactions = {
      all: [],
      unique: []
    }
    this.fee = []
    this.checked200 = false
    this.request = new Request(this.api.bitcoin)
  }
  
  /**
   * The method that starts the synchronization Bitcoin part of wallet
   * @returns {Promise&lt;boolean&gt;}
   * @constructor
   */
  
  async Start () {
    await this.getAddresses()
    await this.processTransactions()
    await this.getFeesRequest()
  }
  
  /**
   * Getting internal and external addresses that were involved in transactions
   * @returns {Promise&lt;boolean&gt;}
   */
  
  async getAddresses () {
    this.addresses.external = await this.getAddressesByNode(
      this.node,
      &apos;external&apos;
    )
    this.addresses.internal = await this.getAddressesByNode(
      this.internalNode,
      &apos;internal&apos;
    )
    this.addresses.empty = {
      external: this.addresses.external[this.addresses.external.length - 1],
      internal: this.addresses.internal[this.addresses.internal.length - 1]
    }

    await this.additionalCheckAddress()

    this.addresses.fullList = [
      ...this.addresses.external,
      ...this.addresses.internal
    ]
    this.addresses.all = this.addresses.fullList.map((item) =&gt; item.address)

    await this.getUnspent()
    this.balance = this.getBalance(this.unspent)
  }
  
  /**
   * Auxiliary method that gets the bitcoin address by node and index
   * @param {Object} node - Bitcoin node
   * @param {string} type - Node type (external or internal)
   * @param {number} from - The index that the derivation starts from
   * @param {number} to - Index to which deprivation occurs
   * @returns {Promise&lt;Array&gt;} Returns array of addresses
   * @private
   */
  
  async _getArrayOfAddresses (node, type, from, to) {
    let addresses = []

    for (let i = from; i &lt; to; i++) {
      let address = &apos;&apos;
      
      if (this.deriveAddress[type].hasOwnProperty(i)) {
        address = this.deriveAddress[type][i]
      } else {
        address = getBtcAddress(node, i)
      }
      addresses.push(address)
    }

    return addresses
  }
  
  /**
   * Getting information about addresses and forming an array of addresses.
   * Makes a request for a bundle of addresses and gets a list of transactions
   * @param node - Bitcoin node
   * @param type - Node type (external or internal)
   * @returns {Promise&lt;Array&gt;} A list of addresses with transactions
   */

  async getAddressesByNode (node, type) {
    const CONTROL_COUNT = 100
    let list = []
    let counter = 0
    let derive_index = 0
    let empty = {
      status: false,
      data: null
    }
    let data = {
      from: 0,
      to: CONTROL_COUNT
    }

    const req = async () =&gt; {
      let addresses = await this._getArrayOfAddresses(
        node,
        type,
        data.from,
        data.to
      )
      
      try {
        let res = await this.getMultiAddressRequest(addresses)
  
        if (res.hasOwnProperty(&apos;txs&apos;)) {
          this.transactions.all = [...this.transactions.all, ...res.txs]
        }
        
        if (res.hasOwnProperty(&apos;addresses&apos;)) {
          for (let i = data.from; i &lt; data.to; i++) {
            if (counter &gt;= CONTROL_COUNT) break
    
            let item = res.addresses.find((itm) =&gt; itm.address === addresses[i])
    
            if (item &amp;&amp; item.n_tx) {
              counter = 0
              empty.status = false
              item.type = type
              item.derive_index = derive_index
              list.push(item)
            } else {
              counter++
              if (!empty.status) {
                item = {}
                item.type = type
                item.derive_index = derive_index
                if (type === &apos;external&apos;) {
                  item.address = getBtcAddress(this.node, derive_index)
                } else {
                  item.address = getBtcAddress(this.internalNode, derive_index)
                }
                empty.status = true
                empty.data = item
              }
            }
            derive_index++
          }
  
          if (counter &lt; CONTROL_COUNT) {
            data.from += CONTROL_COUNT
            data.to += CONTROL_COUNT
            await req()
          } else {
            list.push(empty.data)
          }
        } else {
          let data = {
            type: type,
            derive_index: derive_index
          }
  
          if (type === &apos;external&apos;) {
            data.address = getBtcAddress(this.node, derive_index)
          } else {
            data.address = getBtcAddress(this.internalNode, derive_index)
          }
          
          list.push(data)
        }
      }
      catch (e) {
        console.log(&apos;BTC SyncPromise&apos;, e)
        //TODO: error handler
      }
    }

    await req()
    
    return list
  }

  async additionalCheckAddress () {
    if (!this.checked200 &amp;&amp; !this.deriveAddress.internal.hasOwnProperty(200)) {
      let address = getBtcAddress(this.internalNode, 200)
      this.deriveAddress.internal[200] = address
      this.checked200 = true
      
      let res = await this.getMultiAddressRequest([address])
  
      if (res.hasOwnProperty(&apos;txs&apos;)) {
        this.transactions.all = [...this.transactions.all, ...res.txs]
      }
    
      if (res.hasOwnProperty(&apos;addresses&apos;)) {
        let item = res.addresses.find((itm) =&gt; itm.address === address)

        if (item &amp;&amp; item.n_tx) {
          item.type = &apos;internal&apos;
          item.derive_index = 200

          let lastEmptyAddress = this.addresses.internal.pop()
          this.addresses.internal.push(item)
          this.addresses.internal.push(lastEmptyAddress)
        }
      }
    }
  }
  
  /**
   * Processing transaction information: setting the type (incoming or outgoing),
   * getting addresses from and to, getting a transaction amount
   * @returns {Promise&lt;Boolean&gt;}
   */

  async processTransactions () {
    this.transactions.unique = this.transactions.all.filter(
      (value, index, self) =&gt;
        self.findIndex((tx) =&gt; tx.hash === value.hash) === index
    )

    try {
      this.transactions.unique.forEach((tx) =&gt; {
        let isMyOutAddress = this.addresses.all.indexOf(tx.out[0].addr) &gt;= 0
        let isMyInAddress =
          this.addresses.all.indexOf(tx.inputs[0].prev_out.addr) &gt;= 0

        tx.action = isMyOutAddress ? &apos;incoming&apos; : &apos;outgoing&apos;
        tx.self = isMyOutAddress &amp;&amp; isMyInAddress
        tx.to = tx.out[0].addr
        tx.from = tx.inputs[0].prev_out.addr
        tx.value = tx.out[0].value
      })
    }
    catch (e) {
      console.log(&apos;BTC processTransactions&apos;, e)
    }
  }
  
  /**
   * Getting a unspent transaction output for all addresses in the wallet with the transaction
   * @returns {Promise&lt;boolean&gt;}
   */

  async getUnspent () {
    let res = await this.getUnspentOutputsRequest(this.addresses.all)
    let unspentHash = []
    let unspent = []
    
    res.forEach((item) =&gt; {
      if (unspentHash.indexOf(item.tx_hash_big_endian) &lt; 0) {
        unspentHash.push(item.tx_hash_big_endian)
      }
    })

    for (let hash of unspentHash) {
      let tx = await this.getRawTxRequest(hash)

      if (tx.hasOwnProperty(&apos;out&apos;)) {
        tx.out.forEach((item) =&gt; {
          if (
            !item.spent &amp;&amp;
            item.addr &amp;&amp;
            this.addresses.all.indexOf(item.addr) &gt;= 0
          ) {
            item.hash = tx.hash
            item.key = this.getPrivateKey(item.addr)
            unspent.push(item)
          }
        })
      }
    }

    this.unspent = unspent.sort((a, b) =&gt; b.value - a.value)
  }
  
  /**
   * Getting a balance of Bitcoin wallet from a list of unspent
   * @param {Array} unspent - The list of unspent transaction output
   * @returns {number} The balance of the bitcoin wallet
   */
  
  getBalance (unspent) {
    if (!Array.isArray(unspent)) {
      return 0
    }
    
    let balance = 0
    
    unspent.forEach((item) =&gt; {
      if (item &amp;&amp; item.hasOwnProperty(&apos;value&apos;)) {
        balance += +item.value
      }
    })
    
    return balance
  }
  
  /**
   * Getting a private key at a bitcoin address
   * @param {string} address - Bitcoin address
   * @returns {Object} - Bitcoin private key
   */
  
  getPrivateKey (address) {
    let finded = this.addresses.internal.find(
      (item) =&gt; item.address === address
    )
    let key, wif = null

    if (finded) {
      key = this.internalNode.deriveChild(finded.derive_index).privateKey
      wif = privateKeyToWIF(key)
    } else {
      finded = this.addresses.external.find((item) =&gt; item.address === address)
      key = this.node.deriveChild(finded.derive_index).privateKey
      wif = privateKeyToWIF(key)
    }

    return wif
  }
  
  /**
   * Getting a raw transaction from the transaction hash
   * @param {string} txHash - Transaction hash
   * @returns {Promise&lt;Object&gt;} - Raw transaction
   */

  async getRawTxRequest (txHash) {
    let params = {
      method: &apos;rawtx&apos;,
      tx_hash: txHash
    }

    try {
      let res = await this.request.send(params)
  
      if (res.status === &apos;success&apos;) {
        return res.data
      } else {
        console.log(res.error)
        return {}
      }
    }
    catch (e) {
      console.log(&apos;BTC getLatestBlock&apos;, e)
    }
  }
  
  /**
   * Request for information at multiple addresses
   * @param {Array} addresses - List of addresses to get data from
   * @returns {Promise&lt;Object&gt;} Address information, including a list of transactions
   */

  async getMultiAddressRequest (addresses) {
    if (!addresses) return false
    
    let params = {
      method: &apos;multiaddr&apos;,
      active: addresses
    }

    try {
      let res = await this.request.send(params)
  
      if (res.status === &apos;success&apos;) {
        if (
          res.data.hasOwnProperty(&apos;info&apos;) &amp;&amp;
          res.data.info.hasOwnProperty(&apos;latest_block&apos;)
        ) {
          this.latestBlock = res.data.info.latest_block.height
        }
        return res.data
      } else {
        console.log(res.error)
        return {}
      }
    }
    catch (err) {
      console.log(&apos;BTC getMultiAddressRequest&apos;, err)
    }
  }
  
  /**
   * Request to receive unspent outputs
   * @param {Array} addresses - A set of addresses to get the unspent output from
   * @returns {Promise&lt;Array&gt;} - Information about unspent output
   */

  async getUnspentOutputsRequest (addresses) {
    if (!addresses) return []
    
    let length = 100
    let arraysCount = Math.ceil(addresses.length / length)
    let list = []
    let arrays = []
    
    for (let i = 0; i &lt; arraysCount; i++) {
      let arr = addresses.slice(i * length, (i + 1) * length)
      arrays.push(arr)
    }
    
    return new Promise(resolve =&gt; {
      Promise.all(arrays.map((array) =&gt; {
        return new Promise ((resolve) =&gt; {
          let params = {
            method: &apos;unspent&apos;,
            active: array
          }
      
          this.request.send(params).then(res =&gt; {
            if (res.status === &apos;success&apos;) {
              list = [...res.data.unspent_outputs, ...list]
            }
            
            resolve()
          }).catch(err =&gt; {
            console.log(&apos;BTC getUnspentOutputsRequest&apos;, err)
          })
        })
      })).then(() =&gt; {
        resolve(list)
      })
    })
  }
  
  /**
   * Request to receive a recommended set of bitcoin fees
   * @returns {Promise&lt;Array&gt;} Set of bitcoin fees
   */

  async getFeesRequest () {
    try {
      let res = await fetch(this.api.bitcoinFee)
      this.fee = await res.json()
    }
    catch (err) {
      console.log(&apos;BTC getFeesRequest&apos;, err)
    }
  }
  
  /**
   * Full information about the bitcoin wallet
   * @returns {Object}
   * @constructor
   */

  get DATA () {
    return {
      addresses: this.addresses,
      transactions: this.transactions,
      unspent: this.unspent,
      balance: this.balance,
      latestBlock: this.latestBlock,
      fee: this.fee
    }
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
